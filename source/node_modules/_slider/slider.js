// STACK
var h       = require('virtual-hyperscript-hook')(require('virtual-dom/h'))
var styling = require('_styling')
var s
// CUSTOM
var isretina = require('is-retina')
var defined  = require('defined')
var getval   = require('getval')
var setval   = require('setval')

var defaults =  {
  data          : {
    slider        : {
      width         : 'none',
      slides        : [{
        // @TODO: DEFAULTS - should be removed if data is given
        // => can be solved by using the right "(sub)level-db" instance
        normal: '',
        retina: ''
      }]
    }
  },
  ui            : {
    slider        : {
      focus         : 0
    }
  }
}

module.exports = SliderComponent

/*

REVERSING

.controls
  %button.toggle Prev
  %button.toggle{'data-toggle' => 'next'} Next


.carousel.is-reversing
  transform: translateX(-100%)
  @media (min-width: 30em)
    transform: translateX(-50%)
  @media (min-width: 40em)
    transform: translateX(-33.33333%)

.carousel.is-set
  // after .is-reversing in the cascade

prev = (el) -> if el.prev().length > 0 then el.prev() else seats.last()

$('.toggle').on('click', (e) ->
  # ...

  if $(e.currentTarget).data('toggle') is 'next'
    new_seat = next(el)
    carousel.removeClass('is-reversing')
  else
    new_seat = prev(el)
    carousel.addClass('is-reversing')

  # ...
)
http://codepen.io/nickawalsh/pen/gzwhq
---------------------
Animating:

To start, let’s add is-set to our carousel.
.wrap
  %ul.carousel.is-set
  / ...

is-set is our base state for the carousel. It may seem counterintuitive for the existence of a class to be considered the base state, but it greatly simplifies some features later.

avaScript will remove is-set then re-add it as the seats reorder.
* the same instant the next seat would be visible in the window, is-set disappears, the entire carousel is shifted right, and it appears that the last seat is still active.
* is-set is then re-added, that translation goes away, and a CSS transition smoothly slides us to our new state.

.carousel
  // ...
  transform: translateX(100%)

.carousel.is-set
  transform: none
  transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1)

=> When is-set is not present, our carousel shifts right 100% (the width of one seat, just like our left: -100% adjustment).

=> When is-set is re-added, the transformation is removed, and a transition keeps the whole process nice and smooth.

$('.toggle').on('click', (e) ->
  #...

  carousel.removeClass('is-set')
  setTimeout (-> carousel.addClass('is-set')), 50
)

=> the delay helps with:
  => We have to make the toggle synchronous; carousel.removeClass('is-set').addClass('is-set') happens without the requisite rendering for the effect to work.
  => Adding a slight delay smooths the transition out if users hammer button.

http://codepen.io/nickawalsh/pen/MYbdaB

-----------------------------------------------
Responsiveness:

When the seat width is changed to fit a few in the window, the left adjustment and the transformation that anchors the animation need an update as well (since they’re both based on that width):


.carousel
  // ...
  @media (min-width: 30em)
    left: -50%
    transform: translateX(50%)
  @media (min-width: 40em)
    left: -33.33333%
    transform: translateX(33.33333%)

.carousel-seat
  // ...
  @media (min-width: 30em)
    flex-basis: 50%
  @media (min-width: 40em)
    flex-basis: 33.33333%

=> carousel-seat items have their flex-basis change as the window grows wider, showing an additional item or two if the window can support it. At the same breakpoints on carousel, the left and translate values are updated to reflect the new seat percentage width.

http://codepen.io/nickawalsh/pen/KwNLVR


*/
function SliderComponent (state) {
  s = s ? s : styling(`
    .slider             {
      display           : flex;
      justify-content   : center;
      flex-direction    : row;
      overflow          : hidden;
      max-width         : ${defined(
        getval(state, 'data.page.home.slider.width'),
        defaults.data.slider.width
      )};
    }
    .slide {
      align-self        : center;
      position          : relative;
      width             : 100%;
    }
    .slide-leftout {
      display:none;
      left              : -100%;
    }
    .slide-rightout {
      display:none;
      left              : 100%;
    }

    .animate {
      transition        : transform 0.3s ease-out;
    }

    .carousel {
      display: flex;
      position: relative;
      left: -100%;
    }
    .seat {
      flex: 1 0 100%;
    }
    .show {
      order: 2;
    }

  `)
  return function Slider (namespace, state) {
    var slides = defined(
      getval(state, 'data.page.home.slider.slides'),
      defaults.data.slider.slides
    )
    var focus = defined(
      getval(state, 'ui.'+namespace+'.focus'),
      defaults.ui.slider.focus
    )

    setTimeout(function onclick () {
      setval(state, 'ui.'+namespace+'.focus', ++focus === slides.length ? 0 : focus)
      console.log(focus%slides.length)
      state.action('#! slide2next', state)
    },2000)

    return h('div', [
      // carousel = $('.carousel')
      // seats = $('.carousel-seat')
      //
      //
      // next = (el) -> if el.next().length > 0 then el.next() else seats.first()
      //
      // $('.toggle').on('click', (e) ->
      //   el = $('.is-ref').removeClass('is-ref')
      //
      //   new_seat = next(el)
      //
      //   new_seat.addClass('is-ref').css('order', 1)
      //   new_seat = next(new_seat).css('order', i) for i in [2..seats.length]
      // )
      //
      // We’ll add more to this later (hence the spacing), but for now, here’s what’s happening:
      //
      // Select and store the current reference (is-ref) as el, and remove the reference class from that element.
      // Store the next seat as new_set using our next() function and the el we just stored a second ago.
      // Make the new seat the reference by adding is-ref and setting its order to 1.
      // Loop through all remaining seats in order, starting with our new seat, and change the order property to be one higher than the seat before it.

      // h('div', { className: s('.wrap') }, [
      //   h('ul', { className: s('.carousel') }, [
      //     h('li', { className: focus === 0 ? s('.seat','.show'):s('.seat') }, [
      //       '1'
      //     ]),
      //     h('li', { className: focus === 1 ? s('.seat','.show'):s('.seat') }, [
      //       '2'
      //     ]),
      //     h('li', { className: focus === 2 ? s('.seat','.show'):s('.seat') }, [
      //       '3'
      //     ])
      //   ])
      // ]),
      //
      //

      // h('div', { className: s('.controls') }, [
      //   h('button', { className: s('.controls'),
      //     onclick: function () {
      //       setval(state, 'ui.'+namespace+'.focus', --focus < 0 ? slides.length-1 : focus)
      //       console.log(focus%slides.length)
      //       state.action('#! slide2previous', state)
      //     }
      //   }, ['Previous']),
      //   h('button', { className: s('.controls'),
      //     onclick: function () {
      //       setval(state, 'ui.'+namespace+'.focus', ++focus === slides.length ? 0 : focus)
      //       console.log(focus%slides.length)
      //       state.action('#! slide2next', state)
      //     }
      //   }, ['Next'])
      // ]),

      h('div', {
        className : s('.slider')
      }, slides.map(function (slide, idx) {
        return h('img',  {
          className : idx < focus ? s('.slide', '.slide-leftout')
            : idx > focus ? s('.slide', '.slide-rightout') : s('.slide'),
          // autoplay  : true,
          // loop      : true,
          // muted     : true,
          src       : slide[isretina()?'retina':'normal']
        })
      }))
    ])
  }
}
