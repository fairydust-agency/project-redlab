// STACK
var h       = require('virtual-hyperscript-hook')(require('virtual-dom/h'))
var styling = require('_styling')
var s
// CUSTOM
var isretina = require('is-retina')
var defined  = require('defined')
var getval   = require('getval')
var setval   = require('setval')

var defaults =  {
  data          : {
    slider        : {
      width         : 'none',
      slides        : [{
        // @TODO: DEFAULTS - should be removed if data is given
        // => can be solved by using the right "(sub)level-db" instance
        normal: '',
        retina: ''
      }]
    }
  },
  ui            : {
    slider        : {
      focus         : 0
    }
  }
}

module.exports = SliderComponent

/*

REVERSING

.controls
  %button.toggle Prev
  %button.toggle{'data-toggle' => 'next'} Next


.carousel.is-reversing
  transform: translateX(-100%)
  @media (min-width: 30em)
    transform: translateX(-50%)
  @media (min-width: 40em)
    transform: translateX(-33.33333%)

.carousel.is-set
  // after .is-reversing in the cascade

prev = (el) -> if el.prev().length > 0 then el.prev() else seats.last()

$('.toggle').on('click', (e) ->
  # ...

  if $(e.currentTarget).data('toggle') is 'next'
    new_seat = next(el)
    carousel.removeClass('is-reversing')
  else
    new_seat = prev(el)
    carousel.addClass('is-reversing')

  # ...
)
http://codepen.io/nickawalsh/pen/gzwhq
---------------------
Animating:

To start, let’s add is-set to our carousel.
.wrap
  %ul.carousel.is-set
  / ...

is-set is our base state for the carousel. It may seem counterintuitive for the existence of a class to be considered the base state, but it greatly simplifies some features later.

avaScript will remove is-set then re-add it as the seats reorder.
* the same instant the next seat would be visible in the window, is-set disappears, the entire carousel is shifted right, and it appears that the last seat is still active.
* is-set is then re-added, that translation goes away, and a CSS transition smoothly slides us to our new state.

.carousel
  // ...
  transform: translateX(100%)

.carousel.is-set
  transform: none
  transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1)

=> When is-set is not present, our carousel shifts right 100% (the width of one seat, just like our left: -100% adjustment).

=> When is-set is re-added, the transformation is removed, and a transition keeps the whole process nice and smooth.

$('.toggle').on('click', (e) ->
  #...

  carousel.removeClass('is-set')
  setTimeout (-> carousel.addClass('is-set')), 50
)

=> the delay helps with:
  => We have to make the toggle synchronous; carousel.removeClass('is-set').addClass('is-set') happens without the requisite rendering for the effect to work.
  => Adding a slight delay smooths the transition out if users hammer button.

http://codepen.io/nickawalsh/pen/MYbdaB

-----------------------------------------------
Responsiveness:

When the seat width is changed to fit a few in the window, the left adjustment and the transformation that anchors the animation need an update as well (since they’re both based on that width):


.carousel
  // ...
  @media (min-width: 30em)
    left: -50%
    transform: translateX(50%)
  @media (min-width: 40em)
    left: -33.33333%
    transform: translateX(33.33333%)

.carousel-seat
  // ...
  @media (min-width: 30em)
    flex-basis: 50%
  @media (min-width: 40em)
    flex-basis: 33.33333%

=> carousel-seat items have their flex-basis change as the window grows wider, showing an additional item or two if the window can support it. At the same breakpoints on carousel, the left and translate values are updated to reflect the new seat percentage width.

http://codepen.io/nickawalsh/pen/KwNLVR


*/
function SliderComponent (state) {
  s = s ? s : styling(`
    .banner {
      display           : flex;
      flex-direction    : row;
      width             : 100%;
    }
    .side {
      display           : flex;
      background-color  : ${state.theme.colors.red};
      opacity           : 1;
      position          : relative;
      transition        : opacity 1s linear;
      width             : 100%;
    }
    .side-hidden {
      display           : flex;
      opacity           : 0;
      position          : absolute;
      transition        : opacity 1s linear;
    }
    .slider             {
      display           : flex;
      overflow          : hidden;
      position          : relative;
      width             : ${defined(
        getval(state, 'data.page.home.slider.width'),
        defaults.data.slider.width
      )};
    }
    .slide {
      align-self        : center;
      opacity           : 1;
      position          : relative;
      transition        : opacity 1s linear;
      width             : 100%;
    }
    .slide-hidden {
      align-self        : center;
      opacity           : 0;
      position          : absolute;
      transition        : opacity 1s linear;
    }

  `)
  return function Slider (namespace, state) {
    var slides = defined(
      getval(state, 'data.page.home.slider.slides'),
      defaults.data.slider.slides
    )
    var focus = defined(
      getval(state, 'ui.'+namespace+'.focus'),
      defaults.ui.slider.focus
    )

    if (!id) {
      var id = setTimeout(function onclick () {
        setval(
          state, 'ui.'+namespace+'.focus', ++focus === slides.length ? 0 : focus
        )
        state.action('#! goto slide ' + focus%slides.length, state)
      },2000)
    }

    return h('div', { className: s('.banner') }, [
      h('div', {
        className: focus === 0 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.red') } },
      ''),
      h('div', {
        className: focus === 1 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.lightblue') } },
      ''),
      h('div', {
        className: focus === 2 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.red') } },
      ''),
      h('div', {
        className: focus === 3 ? s('.side') : s('.side', '.side-hidden'),
        style: {
          backgroundColor: getval(state, 'theme.colors.otherorange')
        } },
      ''),
      // h('div', { className: s('.controls') }, [
      //   h('button', { className: s('.controls'),
      //     onclick: function () {
      //       setval(state, 'ui.'+namespace+'.focus', --focus < 0 ? slides.length-1 : focus)
      //       console.log(focus%slides.length)
      //       state.action('#! slide2previous', state)
      //     }
      //   }, ['Previous']),
      //   h('button', { className: s('.controls'),
      //     onclick: function () {
      //       setval(state, 'ui.'+namespace+'.focus', ++focus === slides.length ? 0 : focus)
      //       console.log(focus%slides.length)
      //       state.action('#! slide2next', state)
      //     }
      //   }, ['Next'])
      // ]),

      h('div', {
        className : s('.slider')
      }, slides.map(function (slide, idx) {
        return h('img',  {
          className : idx < focus ? s('.slide', '.slide-hidden')
            : idx > focus ? s('.slide', '.slide-hidden') : s('.slide'),
          // autoplay  : true,
          // loop      : true,
          // muted     : true,
          src       : slide[isretina()?'retina':'normal']
        })
      })),
      h('div', {
        className: focus === 0 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.red') } },
      ''),
      h('div', {
        className: focus === 1 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.lightblue') } },
      ''),
      h('div', {
        className: focus === 2 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.red') } },
      ''),
      h('div', {
        className: focus === 3 ? s('.side') : s('.side', '.side-hidden'),
        style: { backgroundColor: getval(state, 'theme.colors.otherorange') } },
      '')
    ])
  }
}
